:mod:`ethereum.frontier.rlp`
============================

.. py:module:: ethereum.frontier.rlp

Recursive Length Prefix (RLP) Encoding
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. contents:: Table of Contents
    :backlinks: none
    :local:

Introduction
------------

Defines the serialization and deserialization format used throughout Ethereum.


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::
   :nosignatures:

   ethereum.frontier.rlp.encode
   ethereum.frontier.rlp.encode_bytes
   ethereum.frontier.rlp.encode_sequence
   ethereum.frontier.rlp.get_joined_encodings
   ethereum.frontier.rlp.decode
   ethereum.frontier.rlp.decode_to_bytes
   ethereum.frontier.rlp.decode_to_sequence
   ethereum.frontier.rlp.decode_joined_encodings
   ethereum.frontier.rlp.decode_item_length
   ethereum.frontier.rlp.encode_block
   ethereum.frontier.rlp.encode_header
   ethereum.frontier.rlp.encode_account
   ethereum.frontier.rlp.encode_transaction
   ethereum.frontier.rlp.encode_receipt
   ethereum.frontier.rlp.encode_log
   ethereum.frontier.rlp.sequence_to_header
   ethereum.frontier.rlp.sequence_to_transaction
   ethereum.frontier.rlp.decode_to_header
   ethereum.frontier.rlp.decode_to_block
   ethereum.frontier.rlp.rlp_hash



Attributes
~~~~~~~~~~

.. autoapisummary::

   ethereum.frontier.rlp.RLP


Module Details
---------------

RLP
~~~



.. py:data:: RLP

   

.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :lines: 37-47


encode
~~~~~~


.. function:: encode(raw_data: RLP) -> ethereum.base_types.Bytes
   :noindexentry:

   Encodes `raw_data` into a sequence of bytes using RLP.

   :param raw_data: A `Bytes`, `Uint`, `Uint256` or sequence of `RLP` encodable
                    objects.

   :returns: **encoded** -- The RLP encoded bytes representing `raw_data`.
   :rtype: `eth1spec.base_types.Bytes`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: encode

encode_bytes
~~~~~~~~~~~~


.. function:: encode_bytes(raw_bytes: ethereum.base_types.Bytes) -> ethereum.base_types.Bytes
   :noindexentry:

   Encodes `raw_bytes`, a sequence of bytes, using RLP.

   :param raw_bytes: Bytes to encode with RLP.

   :returns: **encoded** -- The RLP encoded bytes representing `raw_bytes`.
   :rtype: `eth1spec.base_types.Bytes`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: encode_bytes

encode_sequence
~~~~~~~~~~~~~~~


.. function:: encode_sequence(raw_sequence: Sequence[RLP]) -> ethereum.base_types.Bytes
   :noindexentry:

   Encodes a list of RLP encodable objects (`raw_sequence`) using RLP.

   :param raw_sequence: Sequence of RLP encodable objects.

   :returns: **encoded** -- The RLP encoded bytes representing `raw_sequence`.
   :rtype: `eth1spec.base_types.Bytes`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: encode_sequence

get_joined_encodings
~~~~~~~~~~~~~~~~~~~~


.. function:: get_joined_encodings(raw_sequence: Sequence[RLP]) -> ethereum.base_types.Bytes
   :noindexentry:

   Obtain concatenation of rlp encoding for each item in the sequence
   raw_sequence.

   :param raw_sequence: Sequence to encode with RLP.

   :returns: **joined_encodings** -- The concatenated RLP encoded bytes for each item in sequence
             raw_sequence.
   :rtype: `eth1spec.base_types.Bytes`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: get_joined_encodings

decode
~~~~~~


.. function:: decode(encoded_data: ethereum.base_types.Bytes) -> RLP
   :noindexentry:

   Decodes an integer, byte sequence, or list of RLP encodable objects
   from the byte sequence `encoded_data`, using RLP.

   :param encoded_data: A sequence of bytes, in RLP form.

   :returns: **decoded_data** -- Object decoded from `encoded_data`.
   :rtype: `RLP`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: decode

decode_to_bytes
~~~~~~~~~~~~~~~


.. function:: decode_to_bytes(encoded_bytes: ethereum.base_types.Bytes) -> ethereum.base_types.Bytes
   :noindexentry:

   Decodes a rlp encoded byte stream assuming that the decoded data
   should be of type `bytes`.

   :param encoded_bytes: RLP encoded byte stream.

   :returns: **decoded** -- RLP decoded Bytes data
   :rtype: `eth1spec.base_types.Bytes`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: decode_to_bytes

decode_to_sequence
~~~~~~~~~~~~~~~~~~


.. function:: decode_to_sequence(encoded_sequence: ethereum.base_types.Bytes) -> List[RLP]
   :noindexentry:

   Decodes a rlp encoded byte stream assuming that the decoded data
   should be of type `Sequence` of objects.

   :param encoded_sequence: An RLP encoded Sequence.

   :returns: **decoded** -- Sequence of objects decoded from `encoded_sequence`.
   :rtype: `Sequence[RLP]`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: decode_to_sequence

decode_joined_encodings
~~~~~~~~~~~~~~~~~~~~~~~


.. function:: decode_joined_encodings(joined_encodings: ethereum.base_types.Bytes) -> List[RLP]
   :noindexentry:

   Decodes `joined_encodings`, which is a concatenation of RLP encoded
   objects.

   :param joined_encodings: concatenation of RLP encoded objects

   :returns: **decoded** -- A list of objects decoded from `joined_encodings`.
   :rtype: `List[RLP]`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: decode_joined_encodings

decode_item_length
~~~~~~~~~~~~~~~~~~


.. function:: decode_item_length(encoded_data: ethereum.base_types.Bytes) -> int
   :noindexentry:

   Find the length of the rlp encoding for the first object in the
   encoded sequence.
   Here `encoded_data` refers to concatenation of rlp encoding for each
   item in a sequence.

   NOTE - This is a helper function not described in the spec. It was
   introduced as the spec doesn't discuss about decoding the RLP encoded
   data.

   :param encoded_data: RLP encoded data for a sequence of objects.

   :returns: **rlp_length**
   :rtype: `int`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: decode_item_length

encode_block
~~~~~~~~~~~~


.. function:: encode_block(raw_block_data: ethereum.frontier.eth_types.Block) -> ethereum.base_types.Bytes
   :noindexentry:

   Encode `Block` dataclass




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: encode_block

encode_header
~~~~~~~~~~~~~


.. function:: encode_header(raw_header_data: ethereum.frontier.eth_types.Header) -> ethereum.base_types.Bytes
   :noindexentry:

   Encode `Header` dataclass




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: encode_header

encode_account
~~~~~~~~~~~~~~


.. function:: encode_account(raw_account_data: ethereum.frontier.eth_types.Account, storage_root: ethereum.base_types.Bytes) -> ethereum.base_types.Bytes
   :noindexentry:

   Encode `Account` dataclass.

   Storage is not stored in the `Account` dataclass, so `Accounts` cannot be
   enocoded with providing a storage root.




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: encode_account

encode_transaction
~~~~~~~~~~~~~~~~~~


.. function:: encode_transaction(raw_tx_data: ethereum.frontier.eth_types.Transaction) -> ethereum.base_types.Bytes
   :noindexentry:

   Encode `Transaction` dataclass




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: encode_transaction

encode_receipt
~~~~~~~~~~~~~~


.. function:: encode_receipt(raw_receipt_data: ethereum.frontier.eth_types.Receipt) -> ethereum.base_types.Bytes
   :noindexentry:

   Encode `Receipt` dataclass




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: encode_receipt

encode_log
~~~~~~~~~~


.. function:: encode_log(raw_log_data: ethereum.frontier.eth_types.Log) -> ethereum.base_types.Bytes
   :noindexentry:

   Encode `Log` dataclass




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: encode_log

sequence_to_header
~~~~~~~~~~~~~~~~~~


.. function:: sequence_to_header(sequence: Sequence[ethereum.base_types.Bytes]) -> ethereum.frontier.eth_types.Header
   :noindexentry:

   Build a Header object from a sequence of bytes. The sequence should be
   containing exactly 15 byte sequences.

   :param sequence: The sequence of bytes which is supposed to form the Header
                    object.

   :returns: **header** -- The obtained `Header` object.
   :rtype: `Header`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: sequence_to_header

sequence_to_transaction
~~~~~~~~~~~~~~~~~~~~~~~


.. function:: sequence_to_transaction(sequence: Sequence[ethereum.base_types.Bytes]) -> ethereum.frontier.eth_types.Transaction
   :noindexentry:

   Build a Transaction object from a sequence of bytes. The sequence should
   be containing exactly 9 byte sequences.

   :param sequence: The sequence of bytes which is supposed to form the Transaction
                    object.

   :returns: **transaction** -- The obtained `Transaction` object.
   :rtype: `Transaction`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: sequence_to_transaction

decode_to_header
~~~~~~~~~~~~~~~~


.. function:: decode_to_header(encoded_header: ethereum.base_types.Bytes) -> ethereum.frontier.eth_types.Header
   :noindexentry:

   Decodes a rlp encoded byte stream assuming that the decoded data
   should be of type `Header`.

   NOTE - This function is valid only till the London Hardfork. Post that
   there would be changes in the Header object as well as this function with
   the introduction of `base_fee` parameter.

   :param encoded_header: An RLP encoded Header.

   :returns: **decoded_header** -- The header object decoded from `encoded_header`.
   :rtype: `Header`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: decode_to_header

decode_to_block
~~~~~~~~~~~~~~~


.. function:: decode_to_block(encoded_block: ethereum.base_types.Bytes) -> ethereum.frontier.eth_types.Block
   :noindexentry:

   Decodes a rlp encoded byte stream assuming that the decoded data
   should be of type `Block`.

   NOTE - This function is valid only till the London Hardfork. Post that
   there would be changes in the Header object as well as this function with
   the introduction of `base_fee` parameter.

   :param encoded_block: An RLP encoded block.

   :returns: **decoded_block** -- The block object decoded from `encoded_block`.
   :rtype: `Block`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: decode_to_block

rlp_hash
~~~~~~~~


.. function:: rlp_hash(data: RLP) -> ethereum.crypto.Hash32
   :noindexentry:

   Obtain the keccak-256 hash of the rlp encoding of the passed in data.

   :param data: The data for which we need the rlp hash.

   :returns: **hash** -- The rlp hash of the passed in data.
   :rtype: `Hash32`




.. undocinclude:: /../src/ethereum/frontier/rlp.py
   :language: python
   :pyobject: rlp_hash
